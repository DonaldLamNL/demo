{"ast":null,"code":"export default {\n  props: {\n    strokeWidth: {\n      type: Number,\n      default: 4\n    },\n    radius: {\n      type: Number,\n      default: 38\n    },\n    transitionDuration: {\n      type: Number,\n      default: 1000\n    },\n    strokeColor: {\n      type: String,\n      default: \"#aaff00\"\n    },\n    value: {\n      validator: function (value) {\n        // should be a number and less or equal than 100\n        return !Number.isNaN(Number(value)) && Number(value) <= 100;\n      },\n      default: \"0.0\"\n    }\n  },\n\n  data() {\n    return {\n      offset: \"\",\n      int: 0,\n      dec: \"00\"\n    };\n  },\n\n  computed: {\n    circumference() {\n      return this.radius * Math.PI * 2;\n    },\n\n    fileStyl() {\n      return {\n        strokeDashoffset: this.offset,\n        \"--initialStroke\": this.circumference,\n        \"--transitionDuration\": `${this.transitionDuration}ms`,\n        \"stroke-width\": this.strokeWidth,\n        stroke: this.strokeColor\n      };\n    },\n\n    circleSize() {\n      return (this.radius + this.strokeWidth) * 2;\n    },\n\n    centralP() {\n      return this.circleSize / 2;\n    }\n\n  },\n  methods: {\n    increaseNumber(number, className) {\n      if (number == 0) {\n        return;\n      }\n\n      const innerNum = parseInt(this.findClosestNumber(this.transitionDuration / 10, number));\n      let interval = this.transitionDuration / innerNum;\n      let counter = 0;\n      const handlerName = `${className}Interval`;\n      this[handlerName] = setInterval(() => {\n        const bitDiff = number.toString().length - innerNum.toString().length;\n\n        if (bitDiff == 0) {\n          this[className] = counter;\n        } else {\n          this[className] = counter * 10 * bitDiff;\n        }\n\n        if (counter === innerNum) {\n          // back to origin precision\n          this[className] = number;\n          window.clearInterval(this[handlerName]);\n        }\n\n        counter++;\n      }, interval);\n    },\n\n    findClosestNumber(bound, value) {\n      if (value <= bound) {\n        return value;\n      }\n\n      return this.findClosestNumber(bound, value / 10);\n    },\n\n    countNumber(v) {\n      this.offset = \"\";\n      this.initTimeoutHandler = setTimeout(() => {\n        this.offset = this.circumference * (100 - v) / 100;\n      }, 100);\n      if (this.$slots.default) return;\n      let [int, dec] = v.toString().split(\".\"); // fallback for NaN\n\n      [int, dec] = [Number(int), Number(dec)];\n      this.increaseNumber(int, \"int\");\n      this.increaseNumber(Number.isNaN(dec) ? 0 : dec, \"dec\");\n    },\n\n    clearHandlers() {\n      if (this.initTimeoutHandler) {\n        clearTimeout(this.initTimeoutHandler);\n      }\n\n      if (this.intInterval) {\n        clearInterval(this.intInterval);\n      }\n\n      if (this.decInterval) {\n        clearInterval(this.decInterval);\n      }\n    }\n\n  },\n  watch: {\n    value: {\n      handler: function (v) {\n        const n = Number(v);\n\n        if (Number.isNaN(n) || n == 0) {\n          return;\n        }\n\n        this.clearHandlers();\n        this.countNumber(v);\n      },\n      immediate: true\n    }\n  },\n\n  beforeDestroy() {\n    this.clearHandlers();\n  }\n\n};","map":null,"metadata":{},"sourceType":"module"}