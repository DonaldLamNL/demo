{"ast":null,"code":"export default {\n  props: {\n    strokeWidth: {\n      type: Number,\n      default: 4\n    },\n    radius: {\n      type: Number,\n      default: 38\n    },\n    transitionDuration: {\n      type: Number,\n      default: 1000\n    },\n    strokeColor: {\n      type: String,\n      default: \"#aaff00\"\n    },\n    value: {\n      validator: function (value) {\n        // should be a number and less or equal than 100\n        return !Number.isNaN(Number(value)) && Number(value) <= 100;\n      },\n      default: \"0.0\"\n    }\n  },\n\n  data() {\n    return {\n      offset: \"\",\n      int: 0,\n      dec: \"00\"\n    };\n  },\n\n  computed: {\n    circumference() {\n      return this.radius * Math.PI * 2;\n    },\n\n    fileStyl() {\n      return {\n        strokeDashoffset: this.offset,\n        \"--initialStroke\": this.circumference,\n        \"--transitionDuration\": `${this.transitionDuration}ms`,\n        \"stroke-width\": this.strokeWidth,\n        stroke: this.strokeColor\n      };\n    },\n\n    circleSize() {\n      return (this.radius + this.strokeWidth) * 2;\n    },\n\n    centralP() {\n      return this.circleSize / 2;\n    }\n\n  },\n  methods: {\n    increaseNumber(number, className) {\n      if (number == 0) {\n        return;\n      }\n\n      const innerNum = parseInt(this.findClosestNumber(this.transitionDuration / 10, number));\n      let interval = this.transitionDuration / innerNum;\n      let counter = 0;\n      const handlerName = `${className}Interval`;\n      this[handlerName] = setInterval(() => {\n        const bitDiff = number.toString().length - innerNum.toString().length;\n\n        if (bitDiff == 0) {\n          this[className] = counter;\n        } else {\n          this[className] = counter * 10 * bitDiff;\n        }\n\n        if (counter === innerNum) {\n          // back to origin precision\n          this[className] = number;\n          window.clearInterval(this[handlerName]);\n        }\n\n        counter++;\n      }, interval);\n    },\n\n    findClosestNumber(bound, value) {\n      if (value <= bound) {\n        return value;\n      }\n\n      return this.findClosestNumber(bound, value / 10);\n    },\n\n    countNumber(v) {\n      this.offset = \"\";\n      this.initTimeoutHandler = setTimeout(() => {\n        this.offset = this.circumference * (100 - v) / 100;\n      }, 100);\n      if (this.$slots.default) return;\n      let [int, dec] = v.toString().split(\".\"); // fallback for NaN\n\n      [int, dec] = [Number(int), Number(dec)];\n      this.increaseNumber(int, \"int\");\n      this.increaseNumber(Number.isNaN(dec) ? 0 : dec, \"dec\");\n    },\n\n    clearHandlers() {\n      if (this.initTimeoutHandler) {\n        clearTimeout(this.initTimeoutHandler);\n      }\n\n      if (this.intInterval) {\n        clearInterval(this.intInterval);\n      }\n\n      if (this.decInterval) {\n        clearInterval(this.decInterval);\n      }\n    }\n\n  },\n  watch: {\n    value: {\n      handler: function (v) {\n        const n = Number(v);\n\n        if (Number.isNaN(n) || n == 0) {\n          return;\n        }\n\n        this.clearHandlers();\n        this.countNumber(v);\n      },\n      immediate: true\n    }\n  },\n\n  beforeDestroy() {\n    this.clearHandlers();\n  }\n\n};","map":{"version":3,"mappings":"AAiCA;EACAA;IACAC;MACAC,YADA;MAEAC;IAFA,CADA;IAKAC;MACAF,YADA;MAEAC;IAFA,CALA;IASAE;MACAH,YADA;MAEAC;IAFA,CATA;IAaAG;MACAJ,YADA;MAEAC;IAFA,CAbA;IAiBAI;MACAC;QACA;QACA;MACA,CAJA;MAKAL;IALA;EAjBA,CADA;;EA0BAM;IACA;MACAC,UADA;MAEAC,MAFA;MAGAC;IAHA;EAKA,CAhCA;;EAiCAC;IACAC;MACA;IACA,CAHA;;IAIAC;MACA;QACAC,6BADA;QAEA,qCAFA;QAGA,sDAHA;QAIA,gCAJA;QAKAC;MALA;IAOA,CAZA;;IAaAC;MACA;IACA,CAfA;;IAgBAC;MACA;IACA;;EAlBA,CAjCA;EAqDAC;IACAC;MACA;QACA;MACA;;MACA,0BACA,4DADA;MAGA;MAEA;MACA;MACA;QACA;;QACA;UACA;QACA,CAFA,MAEA;UACA;QACA;;QACA;UACA;UACA;UACAC;QACA;;QACAC;MACA,CAbA,EAaAC,QAbA;IAcA,CA1BA;;IA2BAC;MACA;QACA;MACA;;MACA;IACA,CAhCA;;IAiCAC;MACA;MAEA;QACA;MACA,CAFA,EAEA,GAFA;MAGA;MACA,yCAPA,CASA;;MACA;MACA;MACA;IACA,CA9CA;;IA+CAC;MACA;QACAC;MACA;;MACA;QACAC;MACA;;MACA;QACAA;MACA;IACA;;EAzDA,CArDA;EAgHAC;IACAvB;MACAwB;QACA;;QACA;UACA;QACA;;QACA;QACA;MACA,CARA;MASAC;IATA;EADA,CAhHA;;EA6HAC;IACA;EACA;;AA/HA","names":["props","strokeWidth","type","default","radius","transitionDuration","strokeColor","value","validator","data","offset","int","dec","computed","circumference","fileStyl","strokeDashoffset","stroke","circleSize","centralP","methods","increaseNumber","window","counter","interval","findClosestNumber","countNumber","clearHandlers","clearTimeout","clearInterval","watch","handler","immediate","beforeDestroy"],"sourceRoot":"node_modules/easy-circular-progress/src","sources":["index.vue"],"sourcesContent":["<template>\n  <div class=\"vue-circular-progress\">\n    <div class=\"circle\">\n      <svg :width=\"circleSize\" :height=\"circleSize\" class=\"circle__svg\">\n        <circle\n          :cx=\"centralP\"\n          :cy=\"centralP\"\n          :r=\"radius\"\n          :style=\"{ 'stroke-width': strokeWidth, stroke: strokeColor }\"\n          class=\"circle__progress circle__progress--path\"\n        ></circle>\n        <circle\n          :cx=\"centralP\"\n          :cy=\"centralP\"\n          :r=\"radius\"\n          :style=\"fileStyl\"\n          class=\"circle__progress circle__progress--fill\"\n        ></circle>\n      </svg>\n\n      <div class=\"percent\">\n        <slot>\n          <span class=\"percent__int\">{{ int }}</span>\n          <span class=\"dot\">.</span>\n          <span class=\"percent__dec\">{{ dec }}</span>\n          <span class=\"percent_sign\">%</span>\n        </slot>\n      </div>\n    </div>\n    <slot name=\"footer\"></slot>\n  </div>\n</template>\n<script>\nexport default {\n  props: {\n    strokeWidth: {\n      type: Number,\n      default: 4\n    },\n    radius: {\n      type: Number,\n      default: 38\n    },\n    transitionDuration: {\n      type: Number,\n      default: 1000\n    },\n    strokeColor: {\n      type: String,\n      default: \"#aaff00\"\n    },\n    value: {\n      validator: function(value) {\n        // should be a number and less or equal than 100\n        return !Number.isNaN(Number(value)) && Number(value) <= 100;\n      },\n      default: \"0.0\"\n    }\n  },\n  data() {\n    return {\n      offset: \"\",\n      int: 0,\n      dec: \"00\"\n    };\n  },\n  computed: {\n    circumference() {\n      return this.radius * Math.PI * 2;\n    },\n    fileStyl() {\n      return {\n        strokeDashoffset: this.offset,\n        \"--initialStroke\": this.circumference,\n        \"--transitionDuration\": `${this.transitionDuration}ms`,\n        \"stroke-width\": this.strokeWidth,\n        stroke: this.strokeColor\n      };\n    },\n    circleSize() {\n      return (this.radius + this.strokeWidth) * 2;\n    },\n    centralP() {\n      return this.circleSize / 2;\n    }\n  },\n  methods: {\n    increaseNumber(number, className) {\n      if (number == 0) {\n        return;\n      }\n      const innerNum = parseInt(\n        this.findClosestNumber(this.transitionDuration / 10, number)\n      );\n      let interval = this.transitionDuration / innerNum;\n\n      let counter = 0;\n      const handlerName = `${className}Interval`;\n      this[handlerName] = setInterval(() => {\n        const bitDiff = number.toString().length - innerNum.toString().length;\n        if (bitDiff == 0) {\n          this[className] = counter;\n        } else {\n          this[className] = counter * 10 * bitDiff;\n        }\n        if (counter === innerNum) {\n          // back to origin precision\n          this[className] = number;\n          window.clearInterval(this[handlerName]);\n        }\n        counter++;\n      }, interval);\n    },\n    findClosestNumber(bound, value) {\n      if (value <= bound) {\n        return value;\n      }\n      return this.findClosestNumber(bound, value / 10);\n    },\n    countNumber(v) {\n      this.offset = \"\";\n\n      this.initTimeoutHandler = setTimeout(() => {\n        this.offset = (this.circumference * (100 - v)) / 100;\n      }, 100);\n      if (this.$slots.default) return;\n      let [int, dec] = v.toString().split(\".\");\n\n      // fallback for NaN\n      [int, dec] = [Number(int), Number(dec)];\n      this.increaseNumber(int, \"int\");\n      this.increaseNumber(Number.isNaN(dec) ? 0 : dec, \"dec\");\n    },\n    clearHandlers() {\n      if (this.initTimeoutHandler) {\n        clearTimeout(this.initTimeoutHandler);\n      }\n      if (this.intInterval) {\n        clearInterval(this.intInterval);\n      }\n      if (this.decInterval) {\n        clearInterval(this.decInterval);\n      }\n    }\n  },\n  watch: {\n    value: {\n      handler: function(v) {\n        const n = Number(v);\n        if (Number.isNaN(n) || n == 0) {\n          return;\n        }\n        this.clearHandlers();\n        this.countNumber(v);\n      },\n      immediate: true\n    }\n  },\n  beforeDestroy() {\n    this.clearHandlers();\n  }\n};\n</script>\n<style lang=\"scss\">\n@import \"index\";\n</style>\n"]},"metadata":{},"sourceType":"module"}